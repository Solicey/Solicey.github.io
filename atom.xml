<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云知计划</title>
  
  <subtitle>Yun Zhi Project</subtitle>
  <link href="https://solicey.github.io/atom.xml" rel="self"/>
  
  <link href="https://solicey.github.io/"/>
  <updated>2022-07-09T08:06:48.117Z</updated>
  <id>https://solicey.github.io/</id>
  
  <author>
    <name>Solitude21</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>03. 光栅化与抗锯齿</title>
    <link href="https://solicey.github.io/wiki/GAMES101/2022-07-09-[03]%E5%85%89%E6%A0%85%E5%8C%96/"/>
    <id>https://solicey.github.io/wiki/GAMES101/2022-07-09-[03]%E5%85%89%E6%A0%85%E5%8C%96/</id>
    <published>2022-07-09T01:52:32.481Z</published>
    <updated>2022-07-09T08:06:48.117Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><ol><li><a href="https://blog.csdn.net/why18767183086/article/details/107369094?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165733197016782395324187%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165733197016782395324187&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-107369094-null-null.142^v32^pc_rank_34,185^v2^control&amp;utm_term=games101%E4%BD%9C%E4%B8%9A2&amp;spm=1018.2226.3001.4187">games101作业02：Triangles and Z-buffering</a></li><li><a href="https://blog.csdn.net/qq_43213160/article/details/124075387?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=games101%E4%BD%9C%E4%B8%9A2&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-124075387.nonecase&amp;spm=1018.2226.3001.4187">Games101 作业2 Triangles and Z-buffering(源码+常见问题)</a></li></ol><p>我们将以作业02作为本小节的动机。</p><h2 id="作业内容"><a href="#作业内容" class="headerlink" title="作业内容"></a>作业内容</h2><p>在上次作业中，虽然我们在屏幕上画出一个线框三角形，但这看起来并不是那么的有趣。所以这一次我们继续推进一步——在屏幕上画出一个实心三角形，换言之，栅格化一个三角形。上一次作业中，在视口变化之后，我们调用了函数<code>rasterize_wireframe(const Triangle&amp; t)</code>。但这一次，你需要自己填写并调用函数 <code>rasterize_triangle(const Triangle&amp; t)</code>。</p><p>该函数的内部工作流程如下：</p><ul><li>创建三角形的 2 维 bounding box。</li><li>遍历此 bounding box 内的所有像素（使用其整数索引）。然后，使用像素中心的屏幕空间坐标来检查中心点是否在三角形内。</li><li>如果在内部，则将其位置处的插值深度值 (interpolated depth value) 与深度缓冲区 (depth buffer) 中的相应值进行比较。</li><li>如果当前点更靠近相机，请设置像素颜色并更新深度缓冲区 (depth buffer)。</li></ul><p>你需要修改的函数如下：</p><ul><li><code>rasterize_triangle()</code>: 执行三角形栅格化算法</li><li><code>static bool insideTriangle()</code>: 测试点是否在三角形内。你可以修改此函数的定义，这意味着，你可以按照自己的方式更新返回类型或函数参数。</li></ul><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="判断像素中心点是否在三角形内"><a href="#判断像素中心点是否在三角形内" class="headerlink" title="判断像素中心点是否在三角形内"></a>判断像素中心点是否在三角形内</h3><p>想要<a href="https://baike.baidu.com/item/%E5%85%89%E6%A0%85%E5%8C%96/10008122?fr=aladdin"><strong>光栅化</strong></a>一个三角形，就得先判断屏幕上的像素是否在三角形的范围内。</p><p>如果把三角形看作由首尾相连的向量围成，那么我们只需判断像素中心点是否在这三个向量的同一侧。假设三角形三个顶点分别为$A,B,C$，像素中心点为$P$，我们进行三次叉乘计算：$\vec{AB}\times \vec{AP},\vec{BC}\times \vec{BP},\vec{CA}\times \vec{CP}$。如果三次运算的结果<strong>都为正或都为负</strong>，那么$P$点在三角形内部。对应代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]</span></span><br><span class="line">    <span class="function">Eigen::Vector2f <span class="title">P</span><span class="params">(x, y)</span></span>;</span><br><span class="line">    Eigen::Vector2f A = _v[<span class="number">0</span>].<span class="built_in">head</span>(<span class="number">2</span>),</span><br><span class="line">                    B = _v[<span class="number">1</span>].<span class="built_in">head</span>(<span class="number">2</span>),</span><br><span class="line">                    C = _v[<span class="number">2</span>].<span class="built_in">head</span>(<span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">    Eigen::Vector2f AP = P - A,</span><br><span class="line">                    BP = P - B,</span><br><span class="line">                    CP = P - C,</span><br><span class="line">                    AB = B - A,</span><br><span class="line">                    BC = C - B,</span><br><span class="line">                    CA = A - C;</span><br><span class="line">    <span class="type">float</span> c1 = AB[<span class="number">0</span>] * AP[<span class="number">1</span>] - AB[<span class="number">1</span>] * AP[<span class="number">0</span>];</span><br><span class="line">    <span class="type">float</span> c2 = BC[<span class="number">0</span>] * BP[<span class="number">1</span>] - BC[<span class="number">1</span>] * BP[<span class="number">0</span>];</span><br><span class="line">    <span class="type">float</span> c3 = CA[<span class="number">0</span>] * CP[<span class="number">1</span>] - CA[<span class="number">1</span>] * CP[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eigen库不支持二维向量的叉乘运算，需要手动列式</span></span><br><span class="line">    <span class="keyword">if</span> ((c1 &gt; <span class="number">0</span> &amp;&amp; c2 &gt; <span class="number">0</span> &amp;&amp; c3 &gt; <span class="number">0</span>) ||</span><br><span class="line">        (c1 &lt; <span class="number">0</span> &amp;&amp; c2 &lt; <span class="number">0</span> &amp;&amp; c3 &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>首先，我们用一个包围盒确定要进行像素中心点判断的范围，这样就能避免每画一个三角形就要遍历整个屏幕的行为。如果我们采用AABB，即<strong>轴对齐包围盒</strong>，那么比较三个顶点的x值y值大小即可确定其范围。为了方便遍历像素点，包围盒的边界需要向外取整。</p><p>接下来，我们遍历包围盒中的像素点，用<code>insideTriangle</code>函数判断其是否在三角形范围内。如果在，那么通过<strong>重心坐标计算</strong>对应的插值深度值，并进行深度检测，即与深度缓冲区的值进行比较。如果当前点更靠近相机，那么设置像素的颜色，并更新深度缓冲区对应的值。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Screen space rasterization</span></span><br><span class="line"><span class="type">void</span> rst::rasterizer::<span class="built_in">rasterize_triangle</span>(<span class="type">const</span> Triangle&amp; t) &#123;</span><br><span class="line">    <span class="keyword">auto</span> v = t.<span class="built_in">toVector4</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 确定包围盒的范围 </span></span><br><span class="line">    <span class="type">float</span> x_min = std::<span class="built_in">min</span>(std::<span class="built_in">min</span>(v[<span class="number">0</span>].<span class="built_in">x</span>(), v[<span class="number">1</span>].<span class="built_in">x</span>()), v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> y_min = std::<span class="built_in">min</span>(std::<span class="built_in">min</span>(v[<span class="number">0</span>].<span class="built_in">y</span>(), v[<span class="number">1</span>].<span class="built_in">y</span>()), v[<span class="number">2</span>].<span class="built_in">y</span>());</span><br><span class="line">    <span class="type">float</span> x_max = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(v[<span class="number">0</span>].<span class="built_in">x</span>(), v[<span class="number">1</span>].<span class="built_in">x</span>()), v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> y_max = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(v[<span class="number">0</span>].<span class="built_in">y</span>(), v[<span class="number">1</span>].<span class="built_in">y</span>()), v[<span class="number">2</span>].<span class="built_in">y</span>());</span><br><span class="line">    x_min = (<span class="type">int</span>)std::<span class="built_in">floor</span>(x_min);</span><br><span class="line">    x_max = (<span class="type">int</span>)std::<span class="built_in">ceil</span>(x_max);</span><br><span class="line">    y_min = (<span class="type">int</span>)std::<span class="built_in">floor</span>(y_min);</span><br><span class="line">    y_max = (<span class="type">int</span>)std::<span class="built_in">ceil</span>(y_max);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历包围盒中的像素，并判断其是否在三角形范围内</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = x_min; x &lt;= x_max; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = y_min; y &lt;= y_max; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">insideTriangle</span>(x + <span class="number">0.5</span>, y + <span class="number">0.5</span>, t.v))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果在，就用重心坐标计算对应的插值深度值</span></span><br><span class="line">                <span class="keyword">auto</span> tup = <span class="built_in">computeBarycentric2D</span>(x, y, t.v);</span><br><span class="line">                <span class="type">float</span> alpha, beta, gamma;</span><br><span class="line">                std::<span class="built_in">tie</span>(alpha, beta, gamma) = tup;</span><br><span class="line">                <span class="type">float</span> w_reciprocal = <span class="number">1.0</span>/(alpha / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma / v[<span class="number">2</span>].<span class="built_in">w</span>());</span><br><span class="line">                <span class="type">float</span> z_interpolated = alpha * v[<span class="number">0</span>].<span class="built_in">z</span>() / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta * v[<span class="number">1</span>].<span class="built_in">z</span>() / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma * v[<span class="number">2</span>].<span class="built_in">z</span>() / v[<span class="number">2</span>].<span class="built_in">w</span>();</span><br><span class="line">                z_interpolated *= w_reciprocal;</span><br><span class="line">                <span class="comment">// ↑重心坐标插值代码由助教提供</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 深度检测：与深度缓冲区中的值进行比较，如果离摄像机更近，那就绘制并更新缓冲区</span></span><br><span class="line">                <span class="keyword">if</span> (z_interpolated &lt; depth_buf[<span class="built_in">get_index</span>(x, y)])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">set_pixel</span>(<span class="built_in">Vector3f</span>(x, y, z_interpolated), t.<span class="built_in">getColor</span>());</span><br><span class="line">                    depth_buf[<span class="built_in">get_index</span>(x, y)] = z_interpolated;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>课程中暂未涉及重心坐标插值，该部分代码由助教提供。如果对此感兴趣，可以看一下这篇文章：<a href="https://zhuanlan.zhihu.com/p/149836719">计算机图形学 1：重心坐标系（Barycentric coordinate system）详解</a></p><h2 id="抗锯齿-反走样"><a href="#抗锯齿-反走样" class="headerlink" title="抗锯齿/反走样"></a>抗锯齿/反走样</h2><p>作业02的附加题如下：</p><blockquote><p>[提高项 5 分] 用 super-sampling 处理 Anti-aliasing : 你可能会注意到，当我们放大图像时，图像边缘会有锯齿感。我们可以用 super-sampling来解决这个问题，即对每个像素进行 2 * 2 采样，并比较前后的结果 (这里并不需要考虑像素与像素间的样本复用)。需要注意的点有，对于像素内的每一个样本都需要维护它自己的深度值，即每一个像素都需要维护一个 sample list。最后，如果你实现正确的话，你得到的三角形不应该有不正常的黑边。</p></blockquote><p>图像边缘有“锯齿”，从信号处理的角度看，这是因为采样的频率低于图像的频率。我们用有限离散的像素点去逼近连续的三角形，自然会出现这种锯齿走样的现象。以下将介绍两种反走样的方法，第二种可以当成第一种的改良。</p><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/484890144">MSAA和SSAA的详细说明</a></p><h3 id="超采样反走样（Super-Sampling-AA）"><a href="#超采样反走样（Super-Sampling-AA）" class="headerlink" title="超采样反走样（Super Sampling AA）"></a>超采样反走样（Super Sampling AA）</h3><p>SSAA的动机非常简单。如果有限离散像素点逼近结果不好，那就用更多的采样点去逼近。我们将原来的每个像素点进行细分。例如，我们可以将一个像素点等分出四个采样点（对应游戏中抗锯齿选项的$\times 2$。对每个采样点计算颜色，然后将像素内部采样点的颜色值全部加起来取平均。</p><p><img src="/wiki/GAMES101/2022-07-09-[03]%E5%85%89%E6%A0%85%E5%8C%96/1.jpg" alt="四等分"></p><p><img src="/wiki/GAMES101/2022-07-09-[03]%E5%85%89%E6%A0%85%E5%8C%96/2.jpg" alt="取平均"></p><p>然而，SSAA存在一定的开销问题。还是以四等分为例：原始的算法会为像素点维护<code>depth_buffer</code>和<code>color_buffer</code>，n个像素点就对应n大小的数组，使用SSAA后，子采样点的深度和颜色也要维护。所以<code>depth_buffer</code>和<code>color_buffer</code>的数组大小就扩充到2*2*n。与此同时，SSAA的计算复杂度也会增大，因为判定是否在三角形内、深度检测和计算着色的操作会增多。</p><h3 id="多采样反走样（Multi-Sampling-AA）"><a href="#多采样反走样（Multi-Sampling-AA）" class="headerlink" title="多采样反走样（Multi-Sampling AA）"></a>多采样反走样（Multi-Sampling AA）</h3><p>MSAA是对SSAA的优化。其思路如下：既然最后显示在屏幕上的是各个母像素的颜色，那么直接从子采样点的三角形覆盖情况得到母像素的颜色就行了。</p><p><img src="/wiki/GAMES101/2022-07-09-[03]%E5%85%89%E6%A0%85%E5%8C%96/4.jpg" alt="举例"></p><p>例如上图中，四个子采样点中有两个在三角形内，在计算完母像素中心的颜色后，将该颜色乘以50%即是最终颜色。以下是MSAA的图示与具体流程：</p><p><img src="/wiki/GAMES101/2022-07-09-[03]%E5%85%89%E6%A0%85%E5%8C%96/3.jpg" alt="MSAA"></p><ol><li>光栅化阶段。对四个$\times$位置的sample执行三角形覆盖判断，在一个四倍分辨率大小的coverage mask中记录每个sample被覆盖的情况，比如下面的2个sample通过了<strong>覆盖测试</strong>，则掩码为0011。</li><li>像素着色阶段。对至少有1个sample通过了覆盖测试的<strong>像素着色</strong>，用像素中心点或者某个已覆盖的sample的坐标执行像素着色器。（注：有的时候，三角形可能没有覆盖到像素的中心位置，这时候如果再使用像素中心点的坐标着色，就可能得到错误的渲染效果。GPU硬件会使用<strong>centroid sampling</strong>来调整采样点的位置，当像素中心点被覆盖时，是正常的像素中心点的采样，而当像素中心点未被三角形覆盖时，GPU就会挑选最近的通过覆盖测试的次像素点，作为采样点。）</li><li>对4个sample中通过覆盖测试的执行<strong>深度测试</strong>，并将测试通过的sample插值得来的深度值写入深度缓冲。每个sample都拥有自己的深度值。</li><li>上图中左下两个sample通过了深度测试，并且coverage mask为1，因此将像素着色阶段得到的颜色copy到这两个sample对应的颜色缓冲中（依然是每个sample一个颜色，共四倍大小）。其他两个sample暂为背景色。</li><li>重复上述流程绘制第二个黄色三角形，将像素着色获得的黄色复制到右上角的sample中。</li><li>所有绘制结束之后，将四个sample的颜色resolve获得最终输出的像素颜色。一般情况下，MSAA是硬件直接用box filter进行resolve，也就是将像素中对应的次像素点中的颜色直接取平均值。</li></ol><p>MSAA与SSAA的最大区别在于，SSAA对像素内的<strong>所有采样点</strong>进行shader计算；而MSAA只选择像素中的一个sample作为采样点，具体挑选哪个点详见第2步。这样就节省了很大一部分的计算开销，尽管MSAA的内存开销还是和SSAA一样多。</p><script type="math/tex; mode=display">\bf{END.}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/why18767183086/article/details/107369094?ops_request_misc=%257B%2522request%255Fid%2522</summary>
      
    
    
    
    <category term="图形学" scheme="https://solicey.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="GAMES101" scheme="https://solicey.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/GAMES101/"/>
    
    
    <category term="CS" scheme="https://solicey.github.io/tags/CS/"/>
    
    <category term="图形学" scheme="https://solicey.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>02. 视图变换</title>
    <link href="https://solicey.github.io/wiki/GAMES101/2022-07-08-[02]%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/"/>
    <id>https://solicey.github.io/wiki/GAMES101/2022-07-08-[02]%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/</id>
    <published>2022-07-08T04:15:03.438Z</published>
    <updated>2022-07-08T13:35:27.463Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><ol><li><a href="https://blog.csdn.net/qq_38065509/article/details/105309174">计算机图形学二：视图变换(坐标系转化，正交投影，透视投影，视口变换)</a></li><li><a href="https://zhuanlan.zhihu.com/p/473031788">一文读懂正交投影变换</a></li></ol><p>视图变换的任务：把三维虚拟世界中以$(x,y,z)$为坐标的物体变换到用一个个像素位置$(x,y)$表示的二维屏幕坐标系中。整个过程可以被细分成如下几个步骤。</p><ol><li>模型变换（modeling transformation）：将虚拟世界中的物体调整至它们应该在的位置。</li><li>摄像机变换（camera transformation）：我们真正在乎的是摄像机所看到的东西，因此需要得到物体与摄像机的相对位置。</li><li>投影变换（projection transformation）：得到所有可视范围内的物体对于摄像机的相对位置坐标$(x,y,z)$后，进行<strong>正交投影</strong>或者<strong>透视投影</strong>，将三维物体投影至<strong>标准二维平面</strong>（$[-1,1]\times[-1,1]$）上。</li><li>视口变换（viewport transformation）：将标准平面映射到屏幕分辨率范围内，即$[-1,1]\times[-1,1]\rightarrow[0,width]\times[0,height]$.</li></ol><p><img src="/wiki/GAMES101/2022-07-08-[02]%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/01.png" alt="示意图"></p><hr><h1 id="模型变换（modeling-transformation）"><a href="#模型变换（modeling-transformation）" class="headerlink" title="模型变换（modeling transformation）"></a>模型变换（modeling transformation）</h1><p>模型变换其实就是利用基本变换矩阵将模型调整至我们想要的地方，详情请见<a href="/wiki/GAMES101/2022-07-07-[01]基本变换矩阵总结/">基本变换矩阵总结</a>。</p><hr><h1 id="摄像机变换（camera-transformation）"><a href="#摄像机变换（camera-transformation）" class="headerlink" title="摄像机变换（camera transformation）"></a>摄像机变换（camera transformation）</h1><p>前面提到，我们需要获得物体与摄像机的相对位置。如果我们把摄像机和物体一起移动，并将摄像机的坐标轴（设为$u,v,w$）移动到世界坐标轴$x,y,z$，那么此时物体的坐标就是与摄像机的相对坐标。</p><p>那么如何让摄像机的坐标系与世界坐标系重合呢？我们先定义三个变量</p><ol><li>摄像机位置(eye position)： $\bf{e}$</li><li>观察方向(gaze position)： $\bf{g}$</li><li>视点正上方向(view-up vector)： $\bf{t}$</li></ol><p>那么我们就可以建立摄像机坐标系了，定义如下：</p><script type="math/tex; mode=display">\begin{aligned}\bf{w} & = -\frac{\bf{g}}{\parallel\bf{g}\parallel}, \\\bf{u} & = \frac{\bf{t}\times \bf{w}}{\parallel\bf{t}\times \bf{w}\parallel},\\\bf{v} & = \bf{w} \times u\end{aligned}</script><p>其中$u,v,w$对应标准坐标系的$x,y,z$。示意图如下所示：</p><p><img src="/wiki/GAMES101/2022-07-08-[02]%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/02.png" alt="示意图"></p><p>其实我感觉，直接拿$\bf{t}$作为基向量也不是不行，而且还更省事一些。</p><p>接下来，就要将其移动到世界坐标系。有如下两个步骤：</p><ol><li>将相机位置移动到世界坐标系原点</li><li>通过旋转矩阵将二者坐标系重合</li></ol><p>第一步只需要简单地减去相机位置坐标$\bf{e}$即可，第二步只需用一个$(u,v,w)^T$矩阵就能将摄像机坐标系旋转至世界坐标系，这部分内容在<a href="/wiki/GAMES101/2022-07-07-[01]基本变换矩阵总结">基本变换矩阵总结</a>中的“绕任意轴旋转”提到过。</p><p>我们定义摄像机变换矩阵$M_{cam}$如下所示：</p><script type="math/tex; mode=display">\bf{M_{cam}}=\begin{bmatrix}\bf{u} & \bf{v} & \bf{w} & \bf{e} \\0 & 0 & 0 & 1 \end{bmatrix}^{-1}=\begin{bmatrix}x_u & y_u & z_u & 0 \\x_v & y_v & z_v & 0 \\x_w & y_w & z_w & 0 \\0 & 0 & 0 & 1\end{bmatrix}\begin{bmatrix}1 & 0 & 0 & -x_e \\0 & 1 & 0 & -y_e \\0 & 0 & 1 & -z_e \\0 & 0 & 0 & 1\end{bmatrix}</script><p>注意到，我们是先位移再线性变换，所以不能直接把两个操作合并成一个<strong><a href="/wiki/GAMES101/2022-07-07-[01]基本变换矩阵总结/#仿射变换">仿射变换</a></strong>矩阵。</p><hr><h1 id="投影变换（projection-transformation）"><a href="#投影变换（projection-transformation）" class="headerlink" title="投影变换（projection transformation）"></a>投影变换（projection transformation）</h1><p>投影变换分为<a href="#正交投影变换"><strong>正交投影变换</strong></a>与<a href="#透视投影变换"><strong>透视投影变换</strong></a>。</p><h2 id="正交投影变换"><a href="#正交投影变换" class="headerlink" title="正交投影变换"></a>正交投影变换</h2><p>在正交投影中，所有的光线都是平行传播。这些平行光将物体的影像垂直地投射到画面上。为了节省计算资源，我们会定义一个“可视空间”，只有在可视空间中的物体才需要绘制。</p><p>正交投影定义的可视空间是一个盒状的空间，由上下左右远近共6个裁切面组成。</p><p><img src="/wiki/GAMES101/2022-07-08-[02]%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/03.jpg" alt="盒状可视空间"></p><p>值得注意的是，由于观察方向是$z$轴的负方向，故$n&gt;f$.</p><p>我们采用如下步骤，将可视空间压缩至一个$[-1,1]^3$的空间当中。规范化坐标系是为了方便移植，使得坐标系独立于各种尺寸的图形设备。为了能够确定物体的前后关系，我们仍需保留$z$轴的值，故我们采用四维的齐次坐标系。</p><ol><li>平移变换：将盒状可视空间的中心点移动到坐标原点。这一步的变换矩阵为：</li></ol><script type="math/tex; mode=display">\bf{M_{translate}}=\begin{bmatrix}1 & 0 & 0 & -\frac{r+l}{2} \\0 & 1 & 0 & -\frac{t+b}{2} \\0 & 0 & 1 & -\frac{n+f}{2} \\0 & 0 & 0 & 1\end{bmatrix}</script><ol><li>缩放变换：通过缩放使其成为范围都是$[-1,1]$的立方体。这一步的变换矩阵为：</li></ol><script type="math/tex; mode=display">\bf{M_{scale}}=\begin{bmatrix}\frac{2}{r-l} & 0 & 0 & 0 \\0 & \frac{2}{t-b} & 0 & 0 \\0 & 0 & \frac{2}{n-f} & 0 \\0 & 0 & 0 & 1\end{bmatrix}</script><p>两个矩阵相乘后就得到了正交投影变换矩阵：</p><script type="math/tex; mode=display">\bf{M_{ortho}}=\bf{M_{scale}}\bf{M_{translate}}=\begin{bmatrix}\frac{2}{r-l} & 0 & 0 & -\frac{r+l}{r-l} \\0 & \frac{2}{t-b} & 0 & -\frac{t+b}{t-b} \\0 & 0 & \frac{2}{n-f} & -\frac{n+f}{n-f} \\0 & 0 & 0 & 1\end{bmatrix}</script><h2 id="透视投影变换"><a href="#透视投影变换" class="headerlink" title="透视投影变换"></a>透视投影变换</h2><p>透视投影遵循近大远小的透视原理，其可视空间不再是“盒状”，而是“四棱台”状。我们希望将这个四棱台“压缩”成盒状，再将其规范化。下图是投影过程的剖面图。</p><p><img src="/wiki/GAMES101/2022-07-08-[02]%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/04.png" alt="透视投影"></p><p>$z=-n$是投影平面。我们将点$(x,y,z)$投影至该平面后，它的坐标变为$(x’,y’,z’)$。利用相似三角形的性质，我们很容易求得$x’$和$y’$。然而，我们希望在变换的过程中，像正交投影那样保留$z$轴的信息以表示物体的远近。简单地令$z’=z$显然不正确，如果我们暂时不知如何解决，不妨先用未知量表示。</p><p>我们希望找到一个矩阵完成如下变换：</p><script type="math/tex; mode=display">\begin{pmatrix}x \\y \\z \\1\end{pmatrix}\Rightarrow\begin{pmatrix}nx/z \\ny/z \\\rm{unknown} \\1\end{pmatrix}\Rightarrow^{(\text{mult. by z})}\begin{pmatrix}nx \\ny \\\rm{still\ unknown} \\z\end{pmatrix}</script><p>即：</p><script type="math/tex; mode=display">\bf{M_{persp\rightarrow ortho}^{(4\times 4)}}\begin{pmatrix}x \\y \\z \\1\end{pmatrix}=\begin{pmatrix}nx \\ny \\\rm{unknown} \\z\end{pmatrix}</script><p>我们很容易地确定了这个矩阵的前两行和最后一行：</p><script type="math/tex; mode=display">\bf{M_{persp\rightarrow ortho}^{(4\times 4)}}=\begin{bmatrix}n & 0 & 0 & 0 \\0 & n & 0 & 0 \\? & ? & ? & ? \\0 & 0 & 1 & 0\end{bmatrix}</script><p>为了确定第三行，我们需要利用透视投影的一个性质：可视空间的<strong>前后面</strong>$z$轴坐标变换前后保持不变。</p><p>设第三行为$(0,0,A,B)$，利用这个性质分别代入远近平面的任意两点就可以列出等式：</p><script type="math/tex; mode=display">\begin{cases}An+B=n^2 \\Af+B=f^2\end{cases}</script><p>容易解得$A=n+f,\ B=-nf$。</p><p>因此变换矩阵为：</p><script type="math/tex; mode=display">\bf{M_{persp\rightarrow ortho}^{(4\times 4)}}=\begin{bmatrix}n & 0 & 0 & 0 \\0 & n & 0 & 0 \\0 & 0 & n+f & -fn \\0 & 0 & 1 & 0\end{bmatrix}</script><p>接下来的操作就和正交投影变换一样了，将压缩得到的盒状空间规范化成标准立方体。</p><script type="math/tex; mode=display">\bf{M_{persp}}=\bf{M_{ortho}}\bf{M_{persp\rightarrow ortho}}=\begin{bmatrix}\frac{2n}{r-l} & 0 & \frac{l+r}{l-r} & 0 \\0 & \frac{2n}{t-b} & \frac{b+t}{b-t} & 0 \\0 & 0 & \frac{f+n}{n-f} & \frac{2fn}{f-n} \\0 & 0 & 1 & 0\end{bmatrix}</script><hr><h1 id="视口变换（viewport-transformation）"><a href="#视口变换（viewport-transformation）" class="headerlink" title="视口变换（viewport transformation）"></a>视口变换（viewport transformation）</h1><p>视口变换就是两个范围空间的转换$[-1,1]\times[-1,1]\rightarrow[0,width]\times[0,height]$，我们可以先缩放，再位移。</p><script type="math/tex; mode=display">\bf{M_{viewport}}=\begin{bmatrix}\frac{width}{2} & 0 & 0 & \frac{width}{2} \\0 & \frac{height}{2} & 0 & \frac{height}{2} \\0 & 0 & 1 & 0 \\0 & 0 & 0 & 1\end{bmatrix}</script><hr><h1 id="总结与作业01"><a href="#总结与作业01" class="headerlink" title="总结与作业01"></a>总结与作业01</h1><p>经历上述四个变换，我们就可以把虚拟世界中的任意可视物体投射到屏幕上了！总的矩阵就是：</p><script type="math/tex; mode=display">\bf{M}=\bf{M_{viewport}}\bf{M_{persp}}\bf{M_{camera}}\bf{M_{model}}</script><p>作业01要求我们完善两个函数：模型变换函数与投影变换函数。</p><ul><li><code>get_model_matrix(float rotation_angle)</code>：<br>构建绕<code>z</code>轴旋转<code>rotation_angle</code>角度的变换矩阵，并返回该矩阵。</li><li><code>get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar)</code>：使用给定的参数，构建透视投影矩阵。<br>其中<code>eye_fov</code>是视场角（竖直方向），<code>aspect_ratio</code>是宽高比。</li></ul><p>代码如下：（代码来源：<a href="https://blog.csdn.net/why18767183086/article/details/107237618?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165728524816781683994957%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165728524816781683994957&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-107237618-null-null.142^v32^pc_rank_34,185^v2^control&amp;utm_term=games101%E4%BD%9C%E4%B8%9A1&amp;spm=1018.2226.3001.4187">games101作业1：旋转与投影</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_model_matrix</span><span class="params">(<span class="type">float</span> angle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Matrix4f rotation;</span><br><span class="line">    angle = angle * MY_PI / <span class="number">180.f</span>;</span><br><span class="line">    rotation &lt;&lt; <span class="built_in">cos</span>(angle), <span class="number">0</span>, <span class="built_in">sin</span>(angle), <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                -<span class="built_in">sin</span>(angle), <span class="number">0</span>, <span class="built_in">cos</span>(angle), <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix4f scale;</span><br><span class="line">    scale &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">              <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">              <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">              <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix4f translate;</span><br><span class="line">    translate &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> translate * rotation * scale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_projection_matrix</span><span class="params">(<span class="type">float</span> eye_fov, <span class="type">float</span> aspect_ratio, <span class="type">float</span> zNear, <span class="type">float</span> zFar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Eigen::Matrix4f projection = Eigen::Matrix4f::<span class="built_in">Identity</span>();</span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">M_persp2ortho</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">M_ortho_scale</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">M_ortho_trans</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> angle = eye_fov * MY_PI / <span class="number">180.0</span>; <span class="comment">// 视场角（弧度制）</span></span><br><span class="line"><span class="type">float</span> height = zNear * <span class="built_in">tan</span>(angle / <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line"><span class="type">float</span> width = height * aspect_ratio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> t = -zNear * <span class="built_in">tan</span>(angle / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> b = -t;</span><br><span class="line"><span class="keyword">auto</span> r = t * aspect_ratio;</span><br><span class="line"><span class="keyword">auto</span> l = -r;</span><br><span class="line"></span><br><span class="line">M_persp2ortho &lt;&lt; zNear, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, zNear, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, zNear + zFar, -zNear * zFar,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">M_ortho_scale &lt;&lt; <span class="number">2</span> / (r - l), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">2</span> / (t - b), <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span> / (zNear - zFar), <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">M_ortho_trans &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -(r + l) / <span class="number">2</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -(t + b) / <span class="number">2</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -(zNear + zFar) / <span class="number">2</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">Eigen::Matrix4f M_ortho = M_ortho_scale * M_ortho_trans;</span><br><span class="line">projection = M_ortho * M_persp2ortho * projection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> projection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">END.</script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_38065509/article/details/105309174&quot;&gt;计算机图形学二：视图变换(坐标系转化，正交投影，透视投影，视口变换)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="图形学" scheme="https://solicey.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="GAMES101" scheme="https://solicey.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/GAMES101/"/>
    
    
    <category term="线性代数" scheme="https://solicey.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="CS" scheme="https://solicey.github.io/tags/CS/"/>
    
    <category term="图形学" scheme="https://solicey.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客备忘录</title>
    <link href="https://solicey.github.io/wiki/Logs/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>https://solicey.github.io/wiki/Logs/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E5%BF%98%E5%BD%95/</id>
    <published>2022-07-07T12:43:12.256Z</published>
    <updated>2022-07-07T13:12:57.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用本地图片"><a href="#引用本地图片" class="headerlink" title="引用本地图片"></a>引用本地图片</h2><p>按照官方的 <a href="https://link.zhihu.com/?target=https%3A//hexo.io/zh-cn/docs/asset-folders.html">asset-folders</a> 的方法处理图片引用，在本地预览时是无法显示的，参考文章 <a href="https://link.zhihu.com/?target=http%3A//etrd.org/2017/01/23/hexo%25E4%25B8%25AD%25E5%25AE%258C%25E7%25BE%258E%25E6%258F%2592%25E5%2585%25A5%25E6%259C%25AC%25E5%259C%25B0%25E5%259B%25BE%25E7%2589%2587/">hexo中完美插入本地图片</a> ，总结出如下的解决方案：</p><p>（1）开启 <code>post_asset_folder</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// config.yml</span><br><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>（2）安装 <code>hexo-asset-image</code> 插件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>（3）使用方式</p><ol><li>在与 <code>_posts/my_article.md</code>的平级位置上创建文件夹 <code>my_article</code>；</li><li>放置 <code>my_article.md</code> 文件中引用到的图片，例如 <code>my_pic.jpg</code>；</li><li>在 <code>my_article.md</code> 以 <code>![my_pic](my_article/my_pic.jpg)</code> 方式引用。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引用本地图片&quot;&gt;&lt;a href=&quot;#引用本地图片&quot; class=&quot;headerlink&quot; title=&quot;引用本地图片&quot;&gt;&lt;/a&gt;引用本地图片&lt;/h2&gt;&lt;p&gt;按照官方的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A</summary>
      
    
    
    
    <category term="日志" scheme="https://solicey.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="hexo" scheme="https://solicey.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>01. 基本变换矩阵总结</title>
    <link href="https://solicey.github.io/wiki/GAMES101/2022-07-07-[01]%E5%9F%BA%E6%9C%AC%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%80%BB%E7%BB%93/"/>
    <id>https://solicey.github.io/wiki/GAMES101/2022-07-07-[01]%E5%9F%BA%E6%9C%AC%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%80%BB%E7%BB%93/</id>
    <published>2022-07-07T12:41:32.987Z</published>
    <updated>2022-07-08T12:15:37.662Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<a href="https://blog.csdn.net/qq_38065509/article/details/105156501">计算机图形学一：基础变换矩阵总结(缩放，旋转，位移)</a></p><h1 id="2D线性变换"><a href="#2D线性变换" class="headerlink" title="2D线性变换"></a>2D线性变换</h1><p>将如下矩阵乘法定义为对向量$(x,y)^T$的线性变换。</p><script type="math/tex; mode=display">\begin{bmatrix}a_{11} & a_{12} \\a_{21} & a_{22}\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}a_{11}x + a_{12}y \\a_{21}x + a_{22}y\end{bmatrix}</script><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>缩放使一种沿着坐标轴作用的变换，定义如下：</p><script type="math/tex; mode=display">scale(s_x,s_y)=\begin{bmatrix}s_x & 0 \\0 & s_y\end{bmatrix}</script><p>即除了$(0,0)^T$保持不变以外，其他点变为$(s_xx,s_yy)^T$.</p><h2 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h2><p>直观理解就是把物体的一边固定，然后拉另外一边。定义如下：</p><script type="math/tex; mode=display">shear-x(s)=\begin{bmatrix}1 & s \\0 & 1\end{bmatrix}\\shear-y(s)=\begin{bmatrix}1 & 0 \\s & 1\end{bmatrix}</script><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>记$\phi$为旋转角度，则定义如下：</p><script type="math/tex; mode=display">rotate(\phi)=\begin{bmatrix}\cos \phi & -\sin\phi \\\sin\phi & \cos\phi\end{bmatrix}</script><p>注意该式是逆时针旋转，且原点为旋转中心。</p><hr><h1 id="3D线性变换"><a href="#3D线性变换" class="headerlink" title="3D线性变换"></a>3D线性变换</h1><h2 id="缩放与旋转"><a href="#缩放与旋转" class="headerlink" title="缩放与旋转"></a>缩放与旋转</h2><script type="math/tex; mode=display">scale(s_x,s_y,s_z)=\begin{bmatrix}s_x & 0 & 0 \\0 & s_y & 0 \\0 & 0 & s_z\end{bmatrix}\\shear-x(d_y,d_z)=\begin{bmatrix}1 & d_y & d_z \\0 & 1 & 0 \\0 & 0 & 1\end{bmatrix}</script><h2 id="绕坐标轴的旋转"><a href="#绕坐标轴的旋转" class="headerlink" title="绕坐标轴的旋转"></a>绕坐标轴的旋转</h2><p>我们采用右手坐标系，故二维中$x$轴向$y$轴旋转，对应到三维便是绕$z$轴旋转。</p><p>同理可推出绕$x$轴旋转（$y$转向$z$），绕$y$轴旋转（$z$转向$x$）。</p><script type="math/tex; mode=display">rotate-z(\phi)=\begin{bmatrix}\cos\phi & -\sin\phi & 0 \\\sin\phi & \cos\phi & 0 \\0 & 0 & 1\end{bmatrix}\\rotate-x(\phi)=\begin{bmatrix}1 & 0 & 0 \\0 & \cos\phi & -\sin\phi \\0 & \sin\phi & \cos\phi\end{bmatrix}\\rotate-y(\phi)=\begin{bmatrix}\cos\phi & 0 & \sin\phi \\0 & 1 & 0 \\-\sin\phi & 0 & \cos\phi\end{bmatrix}\\注意绕y轴\sin的符号有一点不同</script><p>值得注意的是，任意的旋转矩阵都是<strong>正交矩阵</strong>，它们的逆就。eee是它们的转置。</p><h2 id="绕任意轴的旋转"><a href="#绕任意轴的旋转" class="headerlink" title="绕任意轴的旋转"></a>绕任意轴的旋转</h2><p>我们可以将绕任意轴的旋转转化为绕坐标轴的旋转。首先，将该轴旋转至某一坐标轴上，然后就运用上述基本旋转矩阵，最后再逆旋转回来即可。</p><p>设想要围绕旋转的轴为$u$，$R_1$是将$z$旋转到$u$的矩阵。那么旋转矩阵为：$R_1R_zR_1^T$，关键在于如何求出$R_1$。</p><p>我们以$u$作为一轴，构造一个三维正交右手坐标系。将$u$与$z$对齐，此时其它两轴就与$y$和$x$对齐了。构造方法如下：</p><ol><li>任取不与$u$重合的方向$t$.</li><li>令轴$w=t \times u$，$w$对应$y$.</li><li>令轴$v=w\times u$，$v$对应$x$.</li></ol><p>现在我们得到了$v,w,u$，分别对应$x,y,z$。我们取$R_1=(v,w,u)$，该旋转矩阵的含义便是将$x,y,z$旋转到$v,w,u$。知道$R_1$和$R_z$，就可以把旋转矩阵表示出来了。</p><script type="math/tex; mode=display">\begin{bmatrix}x_v & x_w & x_u \\y_v & y_w & y_u \\z_v & z_w & z_u\end{bmatrix}\begin{bmatrix}\cos\phi & -\sin\phi & 0 \\\sin\phi & \cos\phi & 0 \\0 & 0 & 1\end{bmatrix}\begin{bmatrix}x_v & y_v & z_v \\x_w & y_w & z_w \\x_u & y_u & z_u\end{bmatrix}</script><hr><h1 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h1><p>既有旋转缩放等线性变换，又有位移的变换，称为仿射变换。由于位移不是线性变换，故我们需要引入一个新的维度使之“变成”线性变换，称为<strong>齐次坐标</strong>。</p><p>以二维上的点和向量为例。设一<strong>点</strong>为$(x,y)$，其在齐次坐标下就是$(x,y,1)$。设一<strong>向量</strong>为$(u,v)$，其在齐次坐标下是$(u,v,0)$。为什么用$0$表示向量？因为向量的大小方向不随位置的变化而变化，向量的位移没有意义，不需要为此增加一个新的维度。</p><p>假设有如下线性变换：</p><script type="math/tex; mode=display">x' = m_{11}x + m_{12}y \\y' = m_{21}x + m_{22}y</script><p>以及如下位移：</p><script type="math/tex; mode=display">x' = x + x_t \\y' = y + y_t</script><p>那么对应的<strong>仿射变换矩阵</strong>如下。注意：该矩阵<strong>先做线性变换，后做位移</strong>！！</p><script type="math/tex; mode=display">\begin{bmatrix}m_{11} & m_{12} & x_t  \\m_{21} & m_{22} & y_t  \\0 & 0 & 1 \end{bmatrix}</script><p>在<strong><a href="/wiki/GAMES101/2022-07-08-[02]视图变换/#投影变换（projection-transformation）">投影变换</a></strong>中，我们还会用到齐次坐标。</p><script type="math/tex; mode=display">END.</script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考资料：&lt;a href=&quot;https://blog.csdn.net/qq_38065509/article/details/105156501&quot;&gt;计算机图形学一：基础变换矩阵总结(缩放，旋转，位移)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;2D线性变换&quot;&gt;&lt;a href=&quot;#2</summary>
      
    
    
    
    <category term="图形学" scheme="https://solicey.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="GAMES101" scheme="https://solicey.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/GAMES101/"/>
    
    
    <category term="线性代数" scheme="https://solicey.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="CS" scheme="https://solicey.github.io/tags/CS/"/>
    
    <category term="图形学" scheme="https://solicey.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>云知计划3.0</title>
    <link href="https://solicey.github.io/wiki/Logs/hello-world/"/>
    <id>https://solicey.github.io/wiki/Logs/hello-world/</id>
    <published>2022-07-07T05:28:45.540Z</published>
    <updated>2022-07-07T14:45:37.480Z</updated>
    
    <content type="html"><![CDATA[<p>窃以为，创造乃学习的一大动力。</p><p>在高中的时候，我们反反复复地经历各种各样的考试。这些考试会频繁地给予我们正面的或是负面的反馈。正面的反馈鼓舞人心，负面的反馈催人上进。打个不恰当的比喻，考试就如同胡萝卜加大棒，时而给我们尝点甜头，时而又让我们吃点苦。我们在高中时期的学习动力很大一部分来源于这些喜怒无常的考试结果。</p><p>然而，上大学后，我们只能在期中和期末获取来自考试的反馈。如果仍然以考试结果作为学习的主要动力的话，我个人认为这是难以维系的。另外，我们需要认识到，高中时代的落幕意味着应试教育的退场，考试将不再是我们学习的唯一目的。我们从今往后所学的一切知识，都是为了更崇高、也更有意义的目的，那就是创造。</p><p>人与机器的最大差别就在于是否懂得<strong>自主创造</strong>。以往，我们机械地回答着试卷上的一道道问题，考试将我们异化成为了考试而学习的做题机器，我们的一切“创造”都离不开问题的引导。如今，我们若要实现身份的转变，就要学会自己“创造”问题并解决问题，并在此过程中获取巨大的成就感与继续学习的动力。只有这样，我们才能脱离做题家的思维定式，成为一个能够用自身所学自主创造新事物的完整的人。</p><p>云知计划，旨在将我所学到的知识内化于心，外化于一篇篇云端笔记。可以说，高中时代的最大创造活动非记笔记莫属了，但彼时的笔记带有很强的功利性与目的性，<a href="https://solitude21.gitee.io/">云知计划1.0</a>与云知计划2.0仅仅围绕六门主科展开，应试色彩浓厚。如今的云知计划3.0着眼于更广泛的学科内容，收录的所有笔记都将为未来的创造活动提供参考与支持。</p><p>2022.7.7</p><p>Solitude21</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;窃以为，创造乃学习的一大动力。&lt;/p&gt;
&lt;p&gt;在高中的时候，我们反反复复地经历各种各样的考试。这些考试会频繁地给予我们正面的或是负面的反馈。正面的反馈鼓舞人心，负面的反馈催人上进。打个不恰当的比喻，考试就如同胡萝卜加大棒，时而给我们尝点甜头，时而又让我们吃点苦。我们在高中时</summary>
      
    
    
    
    <category term="日志" scheme="https://solicey.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="intro" scheme="https://solicey.github.io/tags/intro/"/>
    
  </entry>
  
</feed>
