<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云知计划</title>
  
  <subtitle>Yun Zhi Project</subtitle>
  <link href="https://solicey.github.io/atom.xml" rel="self"/>
  
  <link href="https://solicey.github.io/"/>
  <updated>2022-07-08T09:25:10.597Z</updated>
  <id>https://solicey.github.io/</id>
  
  <author>
    <name>Solitude21</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>02. 视图变换</title>
    <link href="https://solicey.github.io/wiki/GAMES101/2022-07-08-[02]%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/"/>
    <id>https://solicey.github.io/wiki/GAMES101/2022-07-08-[02]%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/</id>
    <published>2022-07-08T04:15:03.438Z</published>
    <updated>2022-07-08T09:25:10.597Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><ol><li><a href="https://blog.csdn.net/qq_38065509/article/details/105309174">计算机图形学二：视图变换(坐标系转化，正交投影，透视投影，视口变换)</a></li><li><a href="https://zhuanlan.zhihu.com/p/473031788">一文读懂正交投影变换</a></li></ol><p>视图变换的任务：把三维虚拟世界中以$(x,y,z)$为坐标的物体变换到用一个个像素位置$(x,y)$表示的二维屏幕坐标系中。整个过程可以被细分成如下几个步骤。</p><ol><li>模型变换（modeling transformation）：将虚拟世界中的物体调整至它们应该在的位置。</li><li>摄像机变换（camera transformation）：我们真正在乎的是摄像机所看到的东西，因此需要得到物体与摄像机的相对位置。</li><li>投影变换（projection transformation）：得到所有可视范围内的物体对于摄像机的相对位置坐标$(x,y,z)$后，进行<strong>正交投影</strong>或者<strong>透视投影</strong>，将三维物体投影至<strong>标准二维平面</strong>（$[-1,1]\times[-1,1]$）上。</li><li>视口变换（viewport transformation）：将标准平面映射到屏幕分辨率范围内，即$[-1,1]\times[-1,1]\rightarrow[0,width]\times[0,height]$.</li></ol><p><img src="/wiki/GAMES101/2022-07-08-[02]%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/01.png" alt="示意图"></p><h1 id="模型变换（modeling-transformation）"><a href="#模型变换（modeling-transformation）" class="headerlink" title="模型变换（modeling transformation）"></a>模型变换（modeling transformation）</h1><p>模型变换其实就是利用基本变换矩阵将模型调整至我们想要的地方，详情请见<a href="/wiki/GAMES101/2022-07-07-[01]基本变换矩阵总结/">基本变换矩阵总结</a>。</p><h1 id="摄像机变换（camera-transformation）"><a href="#摄像机变换（camera-transformation）" class="headerlink" title="摄像机变换（camera transformation）"></a>摄像机变换（camera transformation）</h1><p>前面提到，我们需要获得物体与摄像机的相对位置。如果我们把摄像机和物体一起移动，并将摄像机的坐标轴（设为$u,v,w$）移动到世界坐标轴$x,y,z$，那么此时物体的坐标就是与摄像机的相对坐标。</p><p>那么如何让摄像机的坐标系与世界坐标系重合呢？我们先定义三个变量</p><ol><li>摄像机位置(eye position)： $\bf{e}$</li><li>观察方向(gaze position)： $\bf{g}$</li><li>视点正上方向(view-up vector)： $\bf{t}$</li></ol><p>那么我们就可以建立摄像机坐标系了，定义如下：</p><script type="math/tex; mode=display">\begin{aligned}\bf{w} & = -\frac{\bf{g}}{\parallel\bf{g}\parallel}, \\\bf{u} & = \frac{\bf{t}\times \bf{w}}{\parallel\bf{t}\times \bf{w}\parallel},\\\bf{v} & = \bf{w} \times u\end{aligned}</script><p>其中$u,v,w$对应标准坐标系的$x,y,z$。示意图如下所示：</p><p><img src="/wiki/GAMES101/2022-07-08-[02]%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/02.png" alt="示意图"></p><p>其实我感觉，直接拿$\bf{t}$作为基向量也不是不行，而且还更省事一些。</p><p>接下来，就要将其移动到世界坐标系。有如下两个步骤：</p><ol><li>将相机位置移动到世界坐标系原点</li><li>通过旋转矩阵将二者坐标系重合</li></ol><p>第一步只需要简单地减去相机位置坐标$\bf{e}$即可，第二步只需用一个$(u,v,w)^T$矩阵就能将摄像机坐标系旋转至世界坐标系，这部分内容在<a href="/wiki/GAMES101/2022-07-07-[01]基本变换矩阵总结">基本变换矩阵总结</a>中的“绕任意轴旋转”提到过。</p><p>我们定义摄像机变换矩阵$M_{cam}$如下所示：</p><script type="math/tex; mode=display">\bf{M_{cam}}=\begin{bmatrix}\bf{u} & \bf{v} & \bf{w} & \bf{e} \\0 & 0 & 0 & 1 \end{bmatrix}^{-1}=\begin{bmatrix}x_u & y_u & z_u & 0 \\x_v & y_v & z_v & 0 \\x_w & y_w & z_w & 0 \\0 & 0 & 0 & 1\end{bmatrix}\begin{bmatrix}1 & 0 & 0 & -x_e \\0 & 1 & 0 & -y_e \\0 & 0 & 1 & -z_e \\0 & 0 & 0 & 1\end{bmatrix}</script><p>注意到，我们是先位移再线性变换，所以不能直接把两个操作合并成一个<strong><a href="/wiki/GAMES101/2022-07-07-[01]基本变换矩阵总结/#仿射变换">仿射变换</a></strong>矩阵。</p><h1 id="投影变换（projection-transformation）"><a href="#投影变换（projection-transformation）" class="headerlink" title="投影变换（projection transformation）"></a>投影变换（projection transformation）</h1><p>投影变换分为<a href="#正交投影变换"><strong>正交投影变换</strong></a>与<a href="#透视投影变换"><strong>透视投影变换</strong></a>。</p><h2 id="正交投影变换"><a href="#正交投影变换" class="headerlink" title="正交投影变换"></a>正交投影变换</h2><p>在正交投影中，所有的光线都是平行传播。这些平行光将物体的影像垂直地投射到画面上。为了节省计算资源，我们会定义一个“可视空间”，只有在可视空间中的物体才需要绘制。</p><p>正交投影定义的可视空间是一个盒状的空间，由上下左右远近共6个裁切面组成。</p><p><img src="/wiki/GAMES101/2022-07-08-[02]%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/03.jpg" alt="盒状可视空间"></p><p>值得注意的是，由于观察方向是$z$轴的负方向，故$n&gt;f$.</p><h2 id="透视投影变换"><a href="#透视投影变换" class="headerlink" title="透视投影变换"></a>透视投影变换</h2><script type="math/tex; mode=display">END.</script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_38065509/article/details/105309174&quot;&gt;计算机图形学二：视图变换(坐标系转化，正交投影，透视投影，视口变换)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="图形学" scheme="https://solicey.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="GAMES101" scheme="https://solicey.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/GAMES101/"/>
    
    
    <category term="线性代数" scheme="https://solicey.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="CS" scheme="https://solicey.github.io/tags/CS/"/>
    
    <category term="图形学" scheme="https://solicey.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客备忘录</title>
    <link href="https://solicey.github.io/wiki/Logs/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>https://solicey.github.io/wiki/Logs/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E5%BF%98%E5%BD%95/</id>
    <published>2022-07-07T12:43:12.256Z</published>
    <updated>2022-07-07T13:12:57.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用本地图片"><a href="#引用本地图片" class="headerlink" title="引用本地图片"></a>引用本地图片</h2><p>按照官方的 <a href="https://link.zhihu.com/?target=https%3A//hexo.io/zh-cn/docs/asset-folders.html">asset-folders</a> 的方法处理图片引用，在本地预览时是无法显示的，参考文章 <a href="https://link.zhihu.com/?target=http%3A//etrd.org/2017/01/23/hexo%25E4%25B8%25AD%25E5%25AE%258C%25E7%25BE%258E%25E6%258F%2592%25E5%2585%25A5%25E6%259C%25AC%25E5%259C%25B0%25E5%259B%25BE%25E7%2589%2587/">hexo中完美插入本地图片</a> ，总结出如下的解决方案：</p><p>（1）开启 <code>post_asset_folder</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// config.yml</span><br><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>（2）安装 <code>hexo-asset-image</code> 插件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>（3）使用方式</p><ol><li>在与 <code>_posts/my_article.md</code>的平级位置上创建文件夹 <code>my_article</code>；</li><li>放置 <code>my_article.md</code> 文件中引用到的图片，例如 <code>my_pic.jpg</code>；</li><li>在 <code>my_article.md</code> 以 <code>![my_pic](my_article/my_pic.jpg)</code> 方式引用。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引用本地图片&quot;&gt;&lt;a href=&quot;#引用本地图片&quot; class=&quot;headerlink&quot; title=&quot;引用本地图片&quot;&gt;&lt;/a&gt;引用本地图片&lt;/h2&gt;&lt;p&gt;按照官方的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A</summary>
      
    
    
    
    <category term="日志" scheme="https://solicey.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="hexo" scheme="https://solicey.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>01. 基本变换矩阵总结</title>
    <link href="https://solicey.github.io/wiki/GAMES101/2022-07-07-[01]%E5%9F%BA%E6%9C%AC%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%80%BB%E7%BB%93/"/>
    <id>https://solicey.github.io/wiki/GAMES101/2022-07-07-[01]%E5%9F%BA%E6%9C%AC%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%80%BB%E7%BB%93/</id>
    <published>2022-07-07T12:41:32.987Z</published>
    <updated>2022-07-08T08:31:09.867Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<a href="https://blog.csdn.net/qq_38065509/article/details/105156501">计算机图形学一：基础变换矩阵总结(缩放，旋转，位移)</a></p><h1 id="2D线性变换"><a href="#2D线性变换" class="headerlink" title="2D线性变换"></a>2D线性变换</h1><p>将如下矩阵乘法定义为对向量$(x,y)^T$的线性变换。</p><script type="math/tex; mode=display">\begin{bmatrix}a_{11} & a_{12} \\a_{21} & a_{22}\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}a_{11}x + a_{12}y \\a_{21}x + a_{22}y\end{bmatrix}</script><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>缩放使一种沿着坐标轴作用的变换，定义如下：</p><script type="math/tex; mode=display">scale(s_x,s_y)=\begin{bmatrix}s_x & 0 \\0 & s_y\end{bmatrix}</script><p>即除了$(0,0)^T$保持不变以外，其他点变为$(s_xx,s_yy)^T$.</p><h2 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h2><p>直观理解就是把物体的一边固定，然后拉另外一边。定义如下：</p><script type="math/tex; mode=display">shear-x(s)=\begin{bmatrix}1 & s \\0 & 1\end{bmatrix}, \quadshear-y(s)=\begin{bmatrix}1 & 0 \\s & 1\end{bmatrix}</script><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>记$\phi$为旋转角度，则定义如下：</p><script type="math/tex; mode=display">rotate(\phi)=\begin{bmatrix}\cos \phi & -\sin\phi \\\sin\phi & \cos\phi\end{bmatrix}</script><p>注意该式是逆时针旋转，且原点为旋转中心。</p><hr><h1 id="3D线性变换"><a href="#3D线性变换" class="headerlink" title="3D线性变换"></a>3D线性变换</h1><h2 id="缩放与旋转"><a href="#缩放与旋转" class="headerlink" title="缩放与旋转"></a>缩放与旋转</h2><script type="math/tex; mode=display">scale(s_x,s_y,s_z)=\begin{bmatrix}s_x & 0 & 0 \\0 & s_y & 0 \\0 & 0 & s_z\end{bmatrix}\\shear-x(d_y,d_z)=\begin{bmatrix}1 & d_y & d_z \\0 & 1 & 0 \\0 & 0 & 1\end{bmatrix}</script><h2 id="绕坐标轴的旋转"><a href="#绕坐标轴的旋转" class="headerlink" title="绕坐标轴的旋转"></a>绕坐标轴的旋转</h2><p>我们采用右手坐标系，故二维中$x$轴向$y$轴旋转，对应到三维便是绕$z$轴旋转。</p><p>同理可推出绕$x$轴旋转（$y$转向$z$），绕$y$轴旋转（$z$转向$x$）。</p><script type="math/tex; mode=display">rotate-z(\phi)=\begin{bmatrix}\cos\phi & -\sin\phi & 0 \\\sin\phi & \cos\phi & 0 \\0 & 0 & 1\end{bmatrix}\\rotate-x(\phi)=\begin{bmatrix}1 & 0 & 0 \\0 & \cos\phi & -\sin\phi \\0 & \sin\phi & \cos\phi\end{bmatrix}\\rotate-y(\phi)=\begin{bmatrix}\cos\phi & 0 & \sin\phi \\0 & 1 & 0 \\-\sin\phi & 0 & \cos\phi\end{bmatrix}\\注意绕y轴\sin的符号有一点不同</script><p>值得注意的是，任意的旋转矩阵都是<strong>正交矩阵</strong>，它们的逆就。eee是它们的转置。</p><h2 id="绕任意轴的旋转"><a href="#绕任意轴的旋转" class="headerlink" title="绕任意轴的旋转"></a>绕任意轴的旋转</h2><p>我们可以将绕任意轴的旋转转化为绕坐标轴的旋转。首先，将该轴旋转至某一坐标轴上，然后就运用上述基本旋转矩阵，最后再逆旋转回来即可。</p><p>设想要围绕旋转的轴为$u$，$R_1$是将$z$旋转到$u$的矩阵。那么旋转矩阵为：$R_1R_zR_1^T$，关键在于如何求出$R_1$。</p><p>我们以$u$作为一轴，构造一个三维正交右手坐标系。将$u$与$z$对齐，此时其它两轴就与$y$和$x$对齐了。构造方法如下：</p><ol><li>任取不与$u$重合的方向$t$.</li><li>令轴$w=t \times u$，$w$对应$y$.</li><li>令轴$v=w\times u$，$v$对应$x$.</li></ol><p>现在我们得到了$v,w,u$，分别对应$x,y,z$。我们取$R_1=(v,w,u)$，该旋转矩阵的含义便是将$x,y,z$旋转到$v,w,u$。知道$R_1$和$R_z$，就可以把旋转矩阵表示出来了。</p><script type="math/tex; mode=display">\begin{bmatrix}x_v & x_w & x_u \\y_v & y_w & y_u \\z_v & z_w & z_u\end{bmatrix}\begin{bmatrix}\cos\phi & -\sin\phi & 0 \\\sin\phi & \cos\phi & 0 \\0 & 0 & 1\end{bmatrix}\begin{bmatrix}x_v & y_v & z_v \\x_w & y_w & z_w \\x_u & y_u & z_u\end{bmatrix}</script><hr><h1 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h1><p>既有旋转缩放等线性变换，又有位移的变换，称为仿射变换。由于位移不是线性变换，故我们需要引入一个新的维度使之“变成”线性变换，称为<strong>齐次坐标</strong>。</p><p>以二维上的点和向量为例。设一<strong>点</strong>为$(x,y)$，其在齐次坐标下就是$(x,y,1)$。设一<strong>向量</strong>为$(u,v)$，其在齐次坐标下是$(u,v,0)$。为什么用$0$表示向量？因为向量的大小方向不随位置的变化而变化，向量的位移没有意义，不需要为此增加一个新的维度。</p><p>假设有如下线性变换：</p><script type="math/tex; mode=display">x' = m_{11}x + m_{12}y \\y' = m_{21}x + m_{22}y</script><p>以及如下位移：</p><script type="math/tex; mode=display">x' = x + x_t \\y' = y + y_t</script><p>那么对应的<strong>仿射变换矩阵</strong>如下。注意：该矩阵<strong>先做线性变换，后做位移</strong>！！</p><script type="math/tex; mode=display">\begin{bmatrix}m_{11} & m_{12} & x_t  \\m_{21} & m_{22} & y_t  \\0 & 0 & 1 \end{bmatrix}</script><p>在<strong><a href="/wiki/GAMES101/2022-07-08-[02]视图变换/#投影变换（projection-transformation）">投影变换</a></strong>中，我们还会用到齐次坐标。</p><script type="math/tex; mode=display">END.</script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考资料：&lt;a href=&quot;https://blog.csdn.net/qq_38065509/article/details/105156501&quot;&gt;计算机图形学一：基础变换矩阵总结(缩放，旋转，位移)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;2D线性变换&quot;&gt;&lt;a href=&quot;#2</summary>
      
    
    
    
    <category term="图形学" scheme="https://solicey.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="GAMES101" scheme="https://solicey.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/GAMES101/"/>
    
    
    <category term="线性代数" scheme="https://solicey.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="CS" scheme="https://solicey.github.io/tags/CS/"/>
    
    <category term="图形学" scheme="https://solicey.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>云知计划3.0</title>
    <link href="https://solicey.github.io/wiki/Logs/hello-world/"/>
    <id>https://solicey.github.io/wiki/Logs/hello-world/</id>
    <published>2022-07-07T05:28:45.540Z</published>
    <updated>2022-07-07T14:45:37.480Z</updated>
    
    <content type="html"><![CDATA[<p>窃以为，创造乃学习的一大动力。</p><p>在高中的时候，我们反反复复地经历各种各样的考试。这些考试会频繁地给予我们正面的或是负面的反馈。正面的反馈鼓舞人心，负面的反馈催人上进。打个不恰当的比喻，考试就如同胡萝卜加大棒，时而给我们尝点甜头，时而又让我们吃点苦。我们在高中时期的学习动力很大一部分来源于这些喜怒无常的考试结果。</p><p>然而，上大学后，我们只能在期中和期末获取来自考试的反馈。如果仍然以考试结果作为学习的主要动力的话，我个人认为这是难以维系的。另外，我们需要认识到，高中时代的落幕意味着应试教育的退场，考试将不再是我们学习的唯一目的。我们从今往后所学的一切知识，都是为了更崇高、也更有意义的目的，那就是创造。</p><p>人与机器的最大差别就在于是否懂得<strong>自主创造</strong>。以往，我们机械地回答着试卷上的一道道问题，考试将我们异化成为了考试而学习的做题机器，我们的一切“创造”都离不开问题的引导。如今，我们若要实现身份的转变，就要学会自己“创造”问题并解决问题，并在此过程中获取巨大的成就感与继续学习的动力。只有这样，我们才能脱离做题家的思维定式，成为一个能够用自身所学自主创造新事物的完整的人。</p><p>云知计划，旨在将我所学到的知识内化于心，外化于一篇篇云端笔记。可以说，高中时代的最大创造活动非记笔记莫属了，但彼时的笔记带有很强的功利性与目的性，<a href="https://solitude21.gitee.io/">云知计划1.0</a>与云知计划2.0仅仅围绕六门主科展开，应试色彩浓厚。如今的云知计划3.0着眼于更广泛的学科内容，收录的所有笔记都将为未来的创造活动提供参考与支持。</p><p>2022.7.7</p><p>Solitude21</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;窃以为，创造乃学习的一大动力。&lt;/p&gt;
&lt;p&gt;在高中的时候，我们反反复复地经历各种各样的考试。这些考试会频繁地给予我们正面的或是负面的反馈。正面的反馈鼓舞人心，负面的反馈催人上进。打个不恰当的比喻，考试就如同胡萝卜加大棒，时而给我们尝点甜头，时而又让我们吃点苦。我们在高中时</summary>
      
    
    
    
    <category term="日志" scheme="https://solicey.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="intro" scheme="https://solicey.github.io/tags/intro/"/>
    
  </entry>
  
</feed>
